# 운영체제

**Contents**

- [운영체제란](#운영체제란)
- [프로세스](#프로세스)
  - [프로세스 상태](#프로세스-상태)
  - [PCB](#PCBProcess-Control-Block)
  - [문맥 교환](#문맥-교환Context-Switching)
- [스레드](#스레드)
- [스케줄러](#스케줄러)
- [인터럽트](#인터럽트)

## 운영체제란

하드웨어와 사용자(와 각종 소프트웨어) 사이를 연결하는 소프트웨어 계층이다.
운영체제도 소프트웨어이기 때문에 컴퓨터 전원이 켜지면 메모리에 운영체제를 올리는 작업을 한다.
하지만 운영체제의 크기는 매우 크기 때문에 핵심적인 부분만 먼저 올리고 나머지 소프트웨어는 필요할 때 메모리에 올려서 사용한다.
전원이 들어오고 부터 메모리에 항상 올려져 있는 운영체제를 `커널`이라고 한다.

### 운영체제의 역할

1. 컴퓨터의 자원(cpu, 메모리, 하드 디스크, 소프트웨어 자원)을 효율적으로 관리하는 역할
2. 사용자 인터페이스 제공

## 프로세스

현재 실행중인 프로그램으로 운영체제로부너 주소공간, 파일, 메모리 등을 할당받는다.
`프로세스 스택`, `데이터 섹션`, `힙`을 포함한다.
운영체제는 프로세스를 생성할 때 `프로세스 제어 블록(PCB)`를 함께 생성한다.
**PCB에 저장되는 내용 **

> 프로그램을 실행시킬 때 프로세스로 실행하는 이유는?

## 프로세스 상태

![](https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Process_states.svg/2000px-Process_states.svg.png)

**new**: 프로세스가 시작되어 그 프로세스를 위한 자료구조는 생성되었으나 아직 메모리를 획득하지 못한 상태
**ready**: 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있는 상태
**running**: 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태
**wait**: 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태
**terminated**: 프로세스가 종료되었으나 운영체제가 해당 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

## PCB(Process Control Block)

운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내 자료구조. 커널 주소공간의 data 영역에 존재한다.

![image.png](https://images.velog.io/post-images/adam2/da888420-3225-11ea-a3ef-9d7ca92bfa81/image.png)

### PCB에 저장되는 내용들

- process 상태 - CPU를 할당해도 되는지 여부를 결정하기 위해 필요함
- pc값
  - 다음에 수행할 명령어의 위치를 가리킨다
- CPU register
  - CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타냄
- CPU 스케줄링 정보
- 메모리 관리 정보
- 자원 사용 정보
- 입출력 상태 정보
- 등등

> 그래서, 프로레스마다 Context가 필요한 이유는 무엇일까?

그 이유는 바로 `문맥교환`이 일어나기 때문이다.

문맥 교환중에 CPU를 선점하고 있던 프로세스는 프로세스 문맥을 자신의 PCB에 저장하게 되고,

새롭게 CPU를 할당받을 프로세스는 PCB로부터 예전에 저장했던 자신의 문맥을 실제 하드웨어로 복원시키는 과정을 거치게 된다.

## 문맥 교환(Context Switching)

문맥 교환이란 하나의 사용자 프로세스로부터 **다른 사용자 프로세스로** CPU의 제어권이 이양되는 과정을 말한다.

실행 상태에 있던 프로세스(A)가 입출력을 요청해야하는 경우가 생겼다고 가정해보자.

입출력을 하기 위해서 프로세스는 I/O를 요청하는 시스템 콜을 발생시키고, 프로세스는 device queue에 줄을 서게 되고 준비 상태로 상태가 변경된다.

그리고 준비 큐에 있던 다른 프로세스(B)가 CPU를 할당받아 명령을 수행하게 될 것이다.

이렇게 프로세스A에게 있던 CPU제어권이 프로세스B에게로 넘어가는 과정을 `문맥 교환`이라고 한다.

> 시스템콜이나 인터럽트로 인해 CPU제어권이 운영체제로 넘어가는 경우에도 프로세스 문맥 중 일부를 PCB에 저장하기는 하지만 이 과정을 문맥 교환이라고 하지는 않는다. 단지 하나의 프로세스가 사용자 모드에서 커널 모드로 실행 모드만 바뀌는 것 뿐이기 때문이다.

문맥 교환에 소요되는 시간은 시스템 입장에서 볼 때 일종의 오버헤드라고 할 수 있다. 따라서 타이머 인터럽트 시간을 너무 짧게하면 프로세스간 문맥 교환이 너무 자주 일어나 오버헤드가 커지게 된다.

## 프로세스 생성

시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만, 그 다음부터는 이미 존재하는 프로세스를 `복제`하여 프로세스를 생성한다.

**복제된 자식 프로세스는 프로세스 식별자를 제외하고 부모 프로세스와 똑같은 문맥을 가지게 된다.** 주소공간, 레지스터 상태, PCB, 커널 스택 등 모든 문맥이 똑같다. 따라서 자식 프로세스를 생성하는 것은 부모가 아이를 낳는 것이 아니라 부모와 똑같은 나이, 똑같은 기억을 가지고 있는 복제 인간을 만드는 것과 같다.

부모 프로세스는 자신이 생성했던 모든 후손 프로세스들이 먼저 죽어야 본인이 종료될 수 있다. 부모 프로세스는 자식 프로세스를 강제로 종료시킬수도 있고, 자식 프로세스가 종료될 때 까지 `wait`상태로 기다릴수도 있다.

## IPC(Inter-process Communication)

하나의 컴퓨터 안에서 실행중인 서로 다른 프로세스간에 발생하는 통신을 말한다.

원래 프로세스는 각각 독립적인 주소공간을 가지고 수행되고 서로의 주소공간을 참조할 수 없다. 하지만 프로세스간 통신을 통해 정보의 공유 등의 이점이 있어 프로세스간 협력 메커니즘이 생겼다.

![](https://media.geeksforgeeks.org/wp-content/uploads/1-76.png)

### 1. 메세지 전달

커널을 통해 메세지를 전달, 수신하는 방법이다.
통신을 원하는 프로세스간에 `커뮤니케이션 링크`를 생성한 후 send(), receive()를 이용해 메세지를 주고받는다. 공유변수를 사용하지 않는다.

종류

- 직접 통신: 통신하려는 프로세스에게 직접 메세지를 전송한다.
- 간접 통신: 메세지를 메일박스 또는 포트로부터 전송받는다.

### 2. 공유 메모리

프로세스들이 메모리의 주소 공간의 일부를 공유하게 된다.
공유 메모리의 동기화를 보장해주어야 한다.

## 스레드

스레드는 한 프로세스 안에서 동작하는 실행 흐름들을 의미한다.
스레드는 프로세스 내의 공간/자원을 공유한다. (코드, 데이터 섹션, 파일, 신호 등등의 운영체제 자원)

**스택을 스레드마다 독립적으로 할당하는 이유는?**

스레드는 독립적인 작업이 가능해야 하기 때문이다.
스택은 되돌아갈 주소값이나 변수 등을 저장하는 곳이다. 이런 스택 공간이 독립적이어냐 독립적인 실행 context를 가질 수 있고 독립적인 실행이 가능하게 된다.

> 스레드도 context-switching을 하는가?

|      | 멀티 스레드                               | 멀티 프로세스                                              |
| ---- | ----------------------------------------- | ---------------------------------------------------------- |
| 장점 | 적은 memory 차지,문맥 전환이 빠름         | 한 프로세스가 죽어도 다른 프로세스에는 영향이 가지 않는다. |
| 단점 | 공유자원이 망가질 경우 모든 스레드에 영향 | 많든 memory와 cpu 차지                                     |

## 스케줄러

### 스케줄링

프로세스가 실행 될 때 필요한 시스템 자원을 할당해주는 작업이다.

프로세스를 스케줄링하기 위한 `큐`는 3가지가 있다.

- `Job Queue`: 프로세스 상태와 무관하게 현재 시스템에 있는 모든 process들이 있다.
- `Ready Queue`: CPU를 할당받기 위해 대기중인 process들이 있다. (`ready` 상태)
- `Divice Queue`: Device I/O작업을 대기중인 process들이 있다. 각 자원마다 큐가 하나씩 존재한다. (`waiting` 상태)

큐는 각 프로세스의 PCB를 연결리스트 형태로 줄세우고 포인터를 활용해 순서를 정한다.

이 큐들에 process를 넣고 빼는 스케줄러도 3가지가 있다.

- 장기 스케줄러(Job Schduler)

  어떤 프로세스를 Ready Queue에 삽입할지를 결정한다.

  `new` -> `ready`

- 중기 스케줄러 (Swapper)

  메모리에 너무 많은 프로세스가 올라가지 않게 조절해주는 역할을 한다. 프로세스를 메모리에서 swap한다.
  메모리에 적재된 프로세스의 수를 동적으로 조절한다.

  메모리에 올라와 있는 프로세스 중 일부에게서 메모리를 통째로 빼앗고 그 내용을 디스크의 `swap 영역`에 저장해둔다. 이 행위를 `swap out`이라고 한다.

  중기 스케줄러의 등장으로 인해 외부적인 이유로 프로세스 수행이 정지된 상태를 나타내는 `suspend`(중지)상태가 새롭게 추가되었다.(terminated와 다름)

  `ready` -> `suspend`

- 후기 스케줄러 (CPU Schduler)

  Ready Queue에 있는 프로세스 중 어떤걸 running시킬지 결정한다.

  `ready` -> `running`

> 현대의 시분할 시스템용 운영체제에서는 장기 스케줄러 대신 중기 스케줄러를 두는 경우가 많다. 요즘 컴퓨터는 메모리가 커서 장기 스케줄러의 필요성이 적어졌다고 한다.

### CPU Schduler 스케줄링 기법

**비선점 스케줄링**

프로세스가 CPU를 할당받으면 다른 프로세스가 강제로 뺏어서 사용할 수 없는(비선점) 방법이다.
그 말은 프로세스 작업이 끝날 때 까지 해당 자원을 사용한다는 것이다.

종류: `FCFS`, `SJF`, `비선점 우선순위`

**선점 스케줄링**

우선순위가 더 높은 프로세스가 강제로 CPU를 뺏어서(선점) 사용할 수 있다. 많은 오버헤드가 생길 수 있다.

종류: `Round Robin`, `SRT`, `선점 우선순위`

## 인터럽트

주변장치와 입출력 장치는 CPU나 메모리와 달리 `인터럽트`라는 메커니즘을 통해 관리된다.

**그래서 인터럽트, 왜 하는거요?**

그 이유는 입출력 연산이 CPU 명령 수행속도보다 현저히 느리기 때문이다.

운영체제를 악덕 사장님, CPU를 비싼 월급 주고 데려온 고오급 인력이라고 생각해보자. 악덕 사장 입장에서는 비싼돈 들여온 만큼 고오급 인력이 쉬지않고 일해서 돈값을 했으면 좋겠다고 생각할 것이다.

![](https://hiphapis.files.wordpress.com/2014/03/screen-shot-2014-03-18-at-4-49-54-pm.png?w=250)

> 내 피같은 돈! 뽕을 뽑아먹겠어! _(고용노동부 국번없이 1350)_

그런데 아주 오래걸리는 입출력 연산을 CPU가 매번 기다린다면(월급루팡 한다면)...? 비싼 돈 주고 모셔온 CPU를 백분 활용하지 못해 운영체제 사장님은 환장할 지경.

CPU가 입출력 처리를 기다리며 쉬는 꼴을 못보는 사장님은 연산 결과가 나올 때 까지 다른 일을 시킨다. 우리 직원 뽕을 뽑아야하니까!

그리고 입출력 직원에게 자신의 업무가 완료되면 그때 CPU선배님에게 작업 완료를 알리라고 일러둔다. CPU가 다시 해당 작업도 이어서 할 수 있도록 한다.

여기서 입출력 직원이 CPU선배님에게 작업 완료를 알려주는 것이 `인터럽트`이다!

## 인터럽트란?

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.

인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉜다.

### 하드웨어 인터럽트

하드웨어가 발생시키는 인터럽트로, CPU가 아닌 다른 하드웨어 장치가 cpu에 어떤 사실을 알려주거나 cpu 서비스를 요청해야 할 경우 발생시킨다.

### 소프트웨어 인터럽트

소프트웨어가 발생시키는 인터럽트이다. 소프트웨어(사용자 프로그램)가 스스로 인터럽트 라인을 세팅한다.

종류: 예외 상황, system call

인터럽트를 발생시키기 위해 하드웨어/소프트웨어는 cpu내에 있는 `인터럽트 라인`을 세팅하여 인터럽트를 발생시킨다.
cpu는 매번 명령을 수행하기 전에 인터럽트라인이 세팅되어있는지를 검사한다.

## 인터럽트 과정

process A 실행 중 디스크에서 어떤 데이터를 읽어오라는 명령을 받았다고 가정해보자.

- process A는 `system call`을 통해 인터럽트를 발생시킨다.
- CPU는 현재 진행 중인 기계어 코드를 완료한다.
- 현재까지 수행중이었던 상태를 해당 process의 **PCB(Process Control Block)**에 저장한다. (수행중이던 MEMORY주소, 레지스터 값, 하드웨어 상태 등...)
- PC(Program Counter, IP)에 다음에 실행할 명령의 주소를 저장한다.
- 인터럽트 벡터를 읽고 ISR 주소값을 얻어 **ISR(Interrupt Service Routine)**로 점프하여 루틴을 실행한다.
- 해당 코드를 실행한다.
- 해당 일을 다 처리하면, 대피시킨 레지스터를 복원한다.
- ISR의 끝에 IRET 명령어에 의해 인터럽트가 해제 된다.
- IRET 명령어가 실행되면, 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원한다.

## 인터럽트와 특권 명령

### 명령어의 종류

CPU가 수행하는 명령에는 `일반 명령`과 `특권 명령`이 있다.

**일반 명령**은 메모리에서 자료를 읽어오고, CPU에서 계산을 하는 등의 명령이고 모든 프로그램이 수행할 수 있는 명령이다.

**특권 명령**은 보안이 필요한 명령으로 입출력 장치, 타이머 등의 장치를 접근하는 명령이다. 특권 명령은 항상 `운영체제`만이 수행할 수 있다.

### kernel mode vs user mode

운영체제는 하드웨어적인 보안을 유지하기 위해 기본적으로 두가지 operation을 지원한다. **kernel mode**는 운영체제가 CPU의 제어권을 가지고 명령을 수행하는 모드로 `일반 명령`과 `특권 명령` 모두 수행할 수 있다.

하지만 **user mode**는 일반 사용자 프로그램이 CPU제어권을 가지고 명령을 수행하는 모드이기 때문에 `일반 명령`만을 수행할 수 있다.

### 과정을 살펴보자

위의 process A가 프로그램 명령 수행중에 디스크 입출력 명령을 읽은 경우를 생각해 보자. 사용자 프로그램은 입출력 장치에 접근하는 명령을 수행할 수 없다. user mode에서 특권 명령을 수행할 수 없기 때문이다.

이련 경우에 사용자 프로그램은 운영체제에게 `시스템 콜`을 통해 특권명령을 대신 수행해달라고 요청한다. 시스템 콜은 주소 공간 자체가 다른 곳(커널의 code영역)으로 이동해야 하므로 **프로그램이 인터럽트 라인에 인터럽트를 세팅**하는 명령을 통해 이루어진다.

> 시스템 콜은 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다.

CPU가 인터럽트 라인을 검사하고 인터럽트가 발생한 것을 감지하게 된다. 현재 수행중인 사용자 프로그램을 잠시 멈추고 CPU의 제어권을 운영체제에게 양도한다. (kernel mode) 그리고 이 때 하드웨어적으로 `모드 비트`가 1에서 0으로 자동으로 세팅되어 특권 명령을 수행할 수 있게 된다.

![image.png](https://images.velog.io/post-images/adam2/77e17e20-2fc9-11ea-a15f-818085aba1cd/image.png)

## 관련 용어

### 인터럽트 핸들러

실제 인터럽트를 처리하기 위한 루틴으로 `인터럽트 서비스 루틴`이라고도 한다.
운영체제의 코드 영역에는 인터럽트별로 처리해야할 내용이 이미 프로그램되어 있다.

### 인터럽트 벡터

인터럽드 발생시 처리해야 할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하고 있는 테이블이다.

### PCB(Process Control Block)

커널의 데이터 영역에 존재하며 각각의 프로세스마다 고유의 PCB가 있다.
인터럽트 발생 시 프로세스의 어느 부분이 수행중이었는지를 저장한다.
(수행중이던 memory 주소, 레지스터값, 하드웨어 상태 ...)
